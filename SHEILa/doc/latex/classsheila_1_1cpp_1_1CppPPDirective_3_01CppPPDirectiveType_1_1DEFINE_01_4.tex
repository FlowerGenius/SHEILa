\hypertarget{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4}{}\section{sheila\+:\+:cpp\+:\+:Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+:\+:D\+E\+F\+I\+NE $>$ Class Template Reference}
\label{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4}\index{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}}


C++ Preprocessor directive specialization for a define directive.  




{\ttfamily \#include $<$Cpp\+P\+P\+Directive.\+h$>$}



Inherits sheila\+::cpp\+::\+Cpp\+P\+P\+Directive\+\_\+base.

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a1511e565d049576911f8d04ce9628fad}{Cpp\+P\+P\+Directive} (\hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature} \&feat, std\+::string id, std\+::string statement, std\+::vector$<$ std\+::string $>$ args=\{\})
\begin{DoxyCompactList}\small\item\em Creates a model of a C++ define directive and a macro object. \end{DoxyCompactList}\item 
\hyperlink{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a1b42adaa10edae5316be28b159485e35}{Cpp\+P\+P\+Directive} (\hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature} $\ast$feat, std\+::string id, std\+::string statement, std\+::vector$<$ std\+::string $>$ args=\{\})
\begin{DoxyCompactList}\small\item\em Creates a model of a C++ define directive and a macro object. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a5fccebd381eeb594c6249eb2a0c70151}{cpp\+\_\+str} ()
\begin{DoxyCompactList}\small\item\em Pure virtual member function promising the ability of derived types of {\ttfamily \hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature}} to be represented in C++ syntax. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_ab46d249d848db43b0b0e4d28ea407bf3}{xml\+\_\+str} ()
\begin{DoxyCompactList}\small\item\em Pure virtual member function promising the ability of derived types of {\ttfamily \hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature}} to be represented in X\+ML syntax. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$$>$\\*
class sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}

C++ Preprocessor directive specialization for a define directive. 

\begin{DoxyAuthor}{Author}
Flower\+Genius
\end{DoxyAuthor}
An explicit specialization of the type D\+E\+F\+I\+NE that represents an abstract model of a C++ preprocessor define directive. 

\subsection{Constructor \& Destructor Documentation}
\index{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}!Cpp\+P\+P\+Directive@{Cpp\+P\+P\+Directive}}
\index{Cpp\+P\+P\+Directive@{Cpp\+P\+P\+Directive}!sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}}
\subsubsection[{\texorpdfstring{Cpp\+P\+P\+Directive(\+Cpp\+Feature \&feat, std\+::string id, std\+::string statement, std\+::vector$<$ std\+::string $>$ args=\lcurly{}\rcurly{})}{CppPPDirective(CppFeature &feat, std::string id, std::string statement, std::vector< std::string > args=\{\})}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sheila\+::cpp\+::\+Cpp\+P\+P\+Directive}$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+NE $>$\+::{\bf Cpp\+P\+P\+Directive} (
\begin{DoxyParamCaption}
\item[{{\bf Cpp\+Feature} \&}]{feat, }
\item[{std\+::string}]{id, }
\item[{std\+::string}]{statement, }
\item[{std\+::vector$<$ std\+::string $>$}]{args = {\ttfamily \{\}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a1511e565d049576911f8d04ce9628fad}{}\label{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a1511e565d049576911f8d04ce9628fad}


Creates a model of a C++ define directive and a macro object. 

\begin{DoxyAuthor}{Author}
Flower\+Genius 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em feat} & Reference to the C++ feature that comes immediately before this directive in the source code. \\
\hline
{\em id} & String that is a (typically) valid macro identifier. \\
\hline
{\em statement} & String that is a (typically) valid macro expression. \\
\hline
{\em args} & Vector of 0 or more strings for the macro arguments.\\
\hline
\end{DoxyParams}
This constructor generates an abstract model of a C++ define directive. It also creates a new macro object representing the macro that has been defined by the directive. \index{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}!Cpp\+P\+P\+Directive@{Cpp\+P\+P\+Directive}}
\index{Cpp\+P\+P\+Directive@{Cpp\+P\+P\+Directive}!sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}}
\subsubsection[{\texorpdfstring{Cpp\+P\+P\+Directive(\+Cpp\+Feature $\ast$feat, std\+::string id, std\+::string statement, std\+::vector$<$ std\+::string $>$ args=\lcurly{}\rcurly{})}{CppPPDirective(CppFeature *feat, std::string id, std::string statement, std::vector< std::string > args=\{\})}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sheila\+::cpp\+::\+Cpp\+P\+P\+Directive}$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+NE $>$\+::{\bf Cpp\+P\+P\+Directive} (
\begin{DoxyParamCaption}
\item[{{\bf Cpp\+Feature} $\ast$}]{feat, }
\item[{std\+::string}]{id, }
\item[{std\+::string}]{statement, }
\item[{std\+::vector$<$ std\+::string $>$}]{args = {\ttfamily \{\}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a1b42adaa10edae5316be28b159485e35}{}\label{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a1b42adaa10edae5316be28b159485e35}


Creates a model of a C++ define directive and a macro object. 

\begin{DoxyAuthor}{Author}
Flower\+Genius 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em feat} & Pointer to the C++ feature that comes immediately before this directive in the source code. \\
\hline
{\em id} & String that is a (typically) valid macro identifier. \\
\hline
{\em statement} & String that is a (typically) valid macro expression. \\
\hline
{\em args} & Vector of 0 or more strings for the macro arguments.\\
\hline
\end{DoxyParams}
This constructor generates an abstract model of a C++ define directive. It also creates a new macro object representing the macro that has been defined by the directive. 

\subsection{Member Function Documentation}
\index{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}!cpp\+\_\+str@{cpp\+\_\+str}}
\index{cpp\+\_\+str@{cpp\+\_\+str}!sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}}
\subsubsection[{\texorpdfstring{cpp\+\_\+str()}{cpp_str()}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string {\bf sheila\+::cpp\+::\+Cpp\+P\+P\+Directive}$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+NE $>$\+::cpp\+\_\+str (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a5fccebd381eeb594c6249eb2a0c70151}{}\label{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_a5fccebd381eeb594c6249eb2a0c70151}


Pure virtual member function promising the ability of derived types of {\ttfamily \hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature}} to be represented in C++ syntax. 

\begin{DoxyAuthor}{Author}
Flower\+Genius 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
C++ string representing this feature in C++ syntax.
\end{DoxyReturn}
Since a {\ttfamily \hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature}} is a C++ lexical component, it must be able to be represented in valid and portable C++ syntax such that it can be inserted into a C++ file and form functioning code. 

Implements \hyperlink{classsheila_1_1cpp_1_1CppFeature_abe57540541227efa5c3e6ef2194276b9}{sheila\+::cpp\+::\+Cpp\+Feature}.

\index{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}!xml\+\_\+str@{xml\+\_\+str}}
\index{xml\+\_\+str@{xml\+\_\+str}!sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$@{sheila\+::cpp\+::\+Cpp\+P\+P\+Directive$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+N\+E $>$}}
\subsubsection[{\texorpdfstring{xml\+\_\+str()}{xml_str()}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string {\bf sheila\+::cpp\+::\+Cpp\+P\+P\+Directive}$<$ Cpp\+P\+P\+Directive\+Type\+::\+D\+E\+F\+I\+NE $>$\+::xml\+\_\+str (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_ab46d249d848db43b0b0e4d28ea407bf3}{}\label{classsheila_1_1cpp_1_1CppPPDirective_3_01CppPPDirectiveType_1_1DEFINE_01_4_ab46d249d848db43b0b0e4d28ea407bf3}


Pure virtual member function promising the ability of derived types of {\ttfamily \hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature}} to be represented in X\+ML syntax. 

\begin{DoxyAuthor}{Author}
Flower\+Genius 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
C++ string representing this feature in X\+ML syntax.
\end{DoxyReturn}
Since a {\ttfamily \hyperlink{classsheila_1_1cpp_1_1CppFeature}{Cpp\+Feature}} is a C++ lexical component, it can be represented using X\+ML.

In the C++ program structure model that is defined in the classes found in this library, any feature of C++ that can be represented in C++ syntax can also be represented in a strictly typed specialization of X\+ML that can be used to form a meta-\/level understanding of a C++ program and each of it\textquotesingle{}s individual components.

TL;DR Any feature of C++ can be represented as an X\+ML tag as well. 

Implements \hyperlink{classsheila_1_1cpp_1_1CppFeature_af32851fe8b1ce92bac4318605f0173db}{sheila\+::cpp\+::\+Cpp\+Feature}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Cpp/\+Cpp\+P\+P\+Directive/Cpp\+P\+P\+Directive.\+h\end{DoxyCompactItemize}
